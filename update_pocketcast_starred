#!/usr/bin/env ruby

require 'bundler/setup'
Bundler.require

require 'open3'
require 'pp'
require 'fileutils'
require 'json'
require 'active_support/core_ext/string/inflections'
require 'net/http'

# Ensure directories exist
%w[data/transcripts data/entities mp3s data/api_results].each do |dir|
  FileUtils.mkdir_p(dir)
end

class PocketcastEpisode
  attr_reader :uuid, :title, :podcast_title, :published_at, :audio_url, :podcast_uuid, :duration
  
  def initialize(data, podcast_title = nil)
    @uuid = data['uuid']
    @title = data['title']
    @podcast_title = podcast_title || data['podcastTitle']
    @published_at = Time.at(data['published'].to_i)
    @audio_url = data['url']
    @podcast_uuid = data['podcastUuid']
    @duration = data['duration']
    @data = data
  end

  def filename
    # Generate safe filename from metadata
    "#{published_at.strftime('%Y%m%d')}_#{podcast_title.parameterize}_#{title.parameterize}.mp3"
  end
  
  def download_path
    File.join('mp3s', filename)
  end
  
  def downloaded?
    File.exist?(download_path)
  end

  def to_h
    {
      uuid: @uuid,
      title: @title,
      podcast_title: @podcast_title,
      published_at: @published_at.iso8601,
      audio_url: @audio_url,
      podcast_uuid: @podcast_uuid,
      duration: @duration,
      filename: filename,
      downloaded: downloaded?,
      raw_data: @data
    }
  end
end

class Pocketcast
  def save_api_result(endpoint, data)
    filename = "data/api_results/#{endpoint}_#{Time.now.strftime('%Y%m%d_%H%M%S')}.json"
    File.write(filename, JSON.pretty_generate(data))
  end

  def get_keys
    puts "Getting keys from 1Password"
    
    # Run the "op item get" command to retrieve the Pocketcast credentials
    output, status = Open3.capture2('op', 'item', 'get', 'pocketcasts.com', '--format', 'json')
    if status.success?
      data = JSON.parse(output)
      
      # Find the username and password fields
      user = data['fields'].find { |f| f['label'] == 'username' }['value']
      password = data['fields'].find { |f| f['label'] == 'password' }['value']

      params = {
        'email' => user,
        'password' => password
      }

      return params
    end

    throw "Couldn't get credentials from 1Password"
  end

  def token
    if !@token
      keys = get_keys
      puts "Logging in"
      response = HTTParty.post('https://api.pocketcasts.com/user/login', {
        query: {
          email: keys['email'],
          password: keys['password'],
          scope: 'webplayer'
        },
        headers: {
          "cache-control" => "no-cache"
        }
      } )

      data = JSON.parse(response.body)
      save_api_result('login', data)
      @token = data['token']
      @email = data['email']
      @user_uuid = data['uuid']
    end

    @token
  end

  def recently_played(limit = 50)
    response = HTTParty.post('https://api.pocketcasts.com/user/history', {
      body: {
        limit: limit
      }.to_json,
      headers: {
        "Authorization" => "Bearer #{token}",
        "cache-control" => "no-cache",
        "Content-Type" => "application/json"
      }
    })

    data = JSON.parse(response.body)
    save_api_result('history', data)

    episodes = data['episodes'].map do |episode_data|
      PocketcastEpisode.new(episode_data)
    end

    episodes
  end

  def starred
    if !@starred
      response = HTTParty.post('https://api.pocketcasts.com/user/starred', {
        query: {},
        headers: {
          "Authorization" => "Bearer #{token}",
          "cache-control" => "no-cache"
        }
      } )

      @starred = JSON.parse(response.body)
      save_api_result('starred', @starred)
    end

    @starred['episodes']
  end

  def podcasts
    if !@podcasts
      response = HTTParty.post('https://api.pocketcasts.com/user/podcast/list', {
        body: {v:1}.to_json,
        headers: {
          "Authorization" => "Bearer #{token}",
          "cache-control" => "no-cache",
        }
      } )

      data = JSON.parse(response.body)
      save_api_result('podcast_list', data)
      
      @podcasts ||= {}

      data['podcasts'].each do |p|
        @podcasts[p['uuid']] = p
      end
    end

    @podcasts
  end

  def share_link episode
    @share_links ||= {}

    if !@share_links[episode['uuid']]
      response = HTTParty.post('https://api.pocketcasts.com/podcasts/share_link', {
        body: {
          episode: episode['uuid'],
          podcast: episode['podcastUuid']
        }.to_json,
        headers: {
          "Authorization" => "Bearer #{token}",
          "cache-control" => "no-cache",
        }
      } )

      data = JSON.parse(response.body)
      save_api_result("share_link_#{episode['uuid']}", data)
      @share_links[episode['uuid']] = data
    end

    @share_links[episode['uuid']]
  end

  def podcast_info(uuid)
    if !podcasts[uuid]
      puts "Loading #{uuid}"

      response = HTTParty.get("https://podcast-api.pocketcasts.com/podcast/full/#{uuid}",
        headers: {
          "Authorization" => "Bearer #{token}",
          "cache-control" => "no-cache",
        } )

      data = JSON.parse(response.body)
      save_api_result("podcast_info_#{uuid}", data)
      podcasts[uuid] = data['podcast']
    end

    podcasts[uuid]
  end    

  def notes(uuid)
    @notes ||= {}

    if !@notes[uuid]
      response = HTTParty.get("https://cache.pocketcasts.com/episode/show_notes/#{uuid}", {
        headers: {
          "Authorization" => "Bearer #{token}",
          "cache-control" => "no-cache",
          "Content-Type" => "application/json"
        }
      } )

      data = JSON.parse(response.body)
      save_api_result("notes_#{uuid}", data)
      @notes[uuid] = data
    end

    @notes[uuid]
  end
end

class PocketcastArchiver
  def initialize
    @pc = Pocketcast.new
    @episodes = load_episode_database
  end

  def sync_recent_episodes
    puts "Fetching recently played episodes..."
    episodes = @pc.recently_played(50)
    
    puts "Found #{episodes.length} episodes"
    episodes.each do |episode|
      puts "Processing #{episode.title}"
      
      # Add to our database if new
      unless @episodes[episode.uuid]
        @episodes[episode.uuid] = episode.to_h
        save_episode_database
      end

      # Download if not already downloaded
      unless episode.downloaded?
        download_episode(episode)
      end
    end
  end

  def list_episodes(filter = {})
    @episodes.values.select do |episode|
      filter.all? { |k, v| episode[k] == v }
    end
  end

  private

  def load_episode_database
    if File.exist?('data/episodes.json')
      JSON.parse(File.read('data/episodes.json'))
    else
      {}
    end
  end

  def save_episode_database
    File.write('data/episodes.json', JSON.pretty_generate(@episodes))
  end

  def download_episode(episode)
    puts "Downloading #{episode.title}..."
    
    uri = URI(episode.audio_url)
    
    Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https') do |http|
      request = Net::HTTP::Get.new(uri)
      
      http.request(request) do |response|
        total_size = response['content-length'].to_i
        progress_bar = nil
        
        # Only show progress bar if we know the size
        if total_size > 0
          progress_bar = ProgressBar.create(
            title: "Downloading",
            total: total_size,
            format: "%t: |%B| %p%% %e"
          )
        end

        File.open(episode.download_path, 'wb') do |file|
          response.read_body do |chunk|
            file.write(chunk)
            progress_bar.progress += chunk.size if progress_bar
          end
        end
      end
    end
    
    puts "Download complete: #{episode.download_path}"
  end
end

if __FILE__ == $0
  archiver = PocketcastArchiver.new
  archiver.sync_recent_episodes
end